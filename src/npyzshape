#!/usr/bin/env python3
import sys
import logging
import zipfile
import io
import argparse
import typing

lformat = '%(filename)s: %(levelname)s: %(message)s'
logging.basicConfig(format=lformat)

import numpy as np
import numpy.lib.format as npf

ERROR_ARGS = 1
ERROR_LOADFILE = 2
ERROR_KEYBOARD = 130


class ArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        self.exit(ERROR_ARGS, '%s: error: %s\n' % (self.prog, message))


def delimiter(string):
    if '\n' in string or '\r' in string:
        raise argparse.ArgumentTypeError
    return string.replace(r'\t', '\t').replace(r'\0', chr(0))


def fields_spec(string) -> typing.List[str]:
    fields = []
    canonical_fields = set()
    candidates = 'fkKsSt'
    for c in string:
        if c not in candidates:
            raise argparse.ArgumentTypeError(
                'Illegal character `{}\' in FIELDS_SPEC "{}"'
                    .format(c, string))
        if c in canonical_fields:
            raise argparse.ArgumentTypeError(
                'Duplicate field specifier `{}\' in FIELDS_SPEC "{}"'
                    .format(c, string))
        fields.append(c)
        canonical_fields.add(c.lower())
    return fields


def make_parser():
    parser = ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='''\
Display array metainfo like shape in numpy npy/npz files. Reading array from
stdin is not supported unless `--reading-header' option is used.

FIELDS_SPEC format

    A sequence of unique single-character field specifier.
    List of field specifiers:

        f      npy/npz filename
        k, K   npz key; if the underlying file is an npy file, empty string is
               displayed if using `k', otherwise "<na>"
        s, S   comma-separated list of shape; if the underlying data is a
               scalar, empty string is displayed if using `s', otherwie
               "<scalar>"
        t      the array dtype
''')
    parser.add_argument('-d', '--field-delimiter', dest='delim',
                        metavar='DELIM', default=':', type=delimiter,
                        help=r"DELIM with `\t', `\0' supported; "
                             r"`\n', `\r' are not allowd. Default to colon")
    parser.add_argument('-H', '--reading-header', action='store_true',
                        help='decide the metainfo by reading the header; '
                             'despite much faster and memory-saving, please '
                             'note that this function may break in the future '
                             'as it uses potentiall unstable API of numpy ('
                             'accessing protected attributes)')
    parser.add_argument('fields_spec', metavar='FIELD_SPEC', type=fields_spec,
                        help='fields specification string')
    parser.add_argument('npyzfiles', metavar='NPYZFILE', nargs='*',
                        help='the npy/npz file(s) to inspect shapes')
    return parser


class NotNpyFileError(Exception):
    pass


def populate_result_dict(data: np.ndarray, fields: typing.Sequence[str]):
    d = {
        's': ','.join(map(str, data.shape)),
        'S': ','.join(map(str, data.shape)) or '<scalar>',
        't': str(data.dtype),
    }
    return {f: d[f] for f in fields if f in d}


def display_result(fields: typing.Sequence[str], delim: str,
                   result_dict: typing.Dict[str, str]) -> None:
    print(delim.join([''.join(('{', f, '}')).format(**result_dict)
                      for f in fields]))


def inspect_npyshape(fp: typing.BinaryIO, fields: typing.Sequence[str]) \
        -> typing.Dict[str, str]:
    """
    :raise NotNpyFileError: if ``fp`` is not an npy file handler
    """
    try:
        return populate_result_dict(None, fields)
    except AttributeError:
        try:
            return populate_result_dict(np.load(fp), fields)
        except OSError as err:
            raise NotNpyFileError from err
    except OSError as err:
        raise NotNpyFileError from err


def inspect_npyshape_h(fp: typing.BinaryIO, *args) -> typing.Dict[str, str]:
    """
    :raise NotNpyFileError:: if ``fp`` is not an npy file handler
    """
    try:
        ver = npf.read_magic(fp)
    except ValueError as err:
        raise NotNpyFileError from err
    else:
        shape, _, dtype = npf._read_array_header(fp, ver)
    return {
        's': ','.join(map(str, shape)),
        'S': ','.join(map(str, shape)) or '<scalar>',
        't': str(dtype),
    }


def inspect_file(filename: str, fields: typing.Sequence[str],
                 delim: str, reading_header: bool) -> int:
    if reading_header:
        inspect_npyshape_ = inspect_npyshape_h
    else:
        inspect_npyshape_ = inspect_npyshape
    retcode = 0
    try:
        zipfile.ZipFile(filename).close()
        with np.load(filename) as zfile:
            for name in zfile:
                try:
                    if set('sSt') & set(fields):
                        data = zfile[name]
                        rd = populate_result_dict(data, fields)
                    else:
                        rd = {}
                    rd.update(f=filename, k=name, K=name)
                    display_result(fields, delim, rd)
                except AttributeError:
                    logging.error('failed to inspect key "%s" in npz '
                                  'file "%s"', name, filename)
    except zipfile.BadZipFile:
        with open(filename, 'rb') as infile:
            try:
                rd = inspect_npyshape_(infile, fields)
                rd.update(f=filename, k='', K='<na>')
                display_result(fields, delim, rd)
            except NotNpyFileError:
                logging.error('failed to load "%s" as npy file', filename)
                retcode |= ERROR_LOADFILE
    except OSError:
        logging.error('failed to load "%s" as npz file', filename)
        retcode |= ERROR_LOADFILE
    return retcode


def main():
    retcode = 0
    try:
        args = make_parser().parse_args()
        for filename in args.npyzfiles:
            retcode |= inspect_file(filename, args.fields_spec, args.delim,
                                    args.reading_header)
    except KeyboardInterrupt:
        retcode |= ERROR_KEYBOARD
    sys.exit(retcode)


if __name__ == '__main__':
    main()
